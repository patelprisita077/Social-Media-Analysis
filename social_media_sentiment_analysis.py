# -*- coding: utf-8 -*-
"""Social Media sentiment Analysis

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1BRWDfoIrX6SaLafNuk07AOWlGRYWSsKB
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import warnings
warnings.filterwarnings('ignore')

df = pd.read_csv('/content/train.csv')

df.head()

df.info()

df['Age'].value_counts()

df1 = df.copy()

wrong_value = ['Male' , 'Female' , 'Non-binary' ,' işte mevcut veri kümesini 1000 satıra tamamlıyorum:']
df1 = df1[~df1['Age'].isin(wrong_value)]

df1 = df1['Age'].astype(int)

df1 = df1.to_frame()

df1['Age'].value_counts()

df.head()

df3 = df.copy()

df3 = df3[~df3["Age"].isin(wrong_value)]


df3["Age"] = df3["Age"].astype(int)

df3.head()

print("The shape of the data is",df3.shape)

gender_count = df3['Gender'].value_counts().reset_index()
gender_count.columns = ['Gender', 'Count']
gender_count

df3['Likes_Received_Per_Day'].groupby(df3['Gender']).value_counts()

df3['Platform'].value_counts()

colors = ['lightgreen', 'blue', 'lightcoral', 'orange', 'lightskyblue','red','pink']

platform_count = df3['Platform'].value_counts()

plt.figure(figsize=(12, 8))
plt.bar(platform_count.index, platform_count.values, color=colors)
plt.xlabel('Platform', fontsize=15)
plt.ylabel('Count', fontsize=15)
plt.title('Count of Users per Platform', fontsize=15)

plt.xticks(rotation=45, fontsize=12)
plt.yticks(fontsize=12)

for i, value in enumerate(platform_count.values):
    plt.text(i, value, str(value), ha='center', va='bottom', fontsize=10)

plt.show()

import plotly.express as px

fig = px.bar(gender_count, x="Gender", y="Count",
             color="Gender",
             color_discrete_map={
                 "Female": "#ff0066",
                 "Male": "#00cc99",
                 "Non-binary": "#6600cc"
             })
fig.update_layout(title="Distinct Count Distribution of Gender")
fig.show()

df3.describe()

plt = px.histogram(df3,x="Age",color="Gender",barmode="group",nbins=20)
plt.show()

df['Platform'].value_counts()

plt = px.histogram(df3,x="Platform",color="Gender",barmode="group",nbins=20,title= 'Platform Distribution')
plt.show()

df3['Daily_Usage_Time (minutes)'].value_counts()

plt = px.histogram(df3, x='Daily_Usage_Time (minutes)', color='Gender', barmode='group', nbins=20, title='Daily Usage Time Distribution')
plt.show()

column_names = df3.columns
x_column = "Posts_Per_Day"

if x_column not in column_names:
    raise ValueError(f"Column '{x_column}' not found in DataFrame")

plt = px.histogram(df3, x=x_column, color="Gender", barmode="group", nbins=20, title='Posts Per Day Distribution')
plt.show()

df3['Dominant_Emotion'].unique()

df3['Dominant_Emotion'].fillna(df3['Dominant_Emotion'].mode()[0], inplace=True)

plt = px.pie(df3, names='Dominant_Emotion', title='Dominant Emotion Distribution')

plt.update_traces(textposition='inside', textinfo='percent+label')
plt.show()

grouped = df3.groupby(['Age', 'Gender'])


counts = grouped.size()

print(counts)

import seaborn as sns
import matplotlib.pyplot as plt

sns.scatterplot(x='Daily_Usage_Time (minutes)', y='Posts_Per_Day', data=df3)
plt.title('Scatter Plot of Daily Usage Time vs. Posts Per Day') # Use matplotlib.pyplot's plt to set the title
plt.show()

mode_emotion_by_gender = df3.groupby('Gender')['Dominant_Emotion'].agg(pd.Series.mode)


print("Mode dominant emotion for females:", mode_emotion_by_gender['Female'])
print("Mode dominant emotion for males:", mode_emotion_by_gender['Male'])
print("Mode dominant emotion for non-binary:", mode_emotion_by_gender['Non-binary'])


emotion_counts_by_gender = df3.groupby(['Gender', 'Dominant_Emotion'])['Dominant_Emotion'].count()
print(emotion_counts_by_gender)

sns.violinplot(x='Gender', y='Dominant_Emotion', data=df3)
plt.title('Violin Plot of Dominant Emotion by Gender')
plt.show()

grouped_likes = df3.groupby('Platform')['Daily_Usage_Time (minutes)'].mean().reset_index()


plt.figure(figsize=(10, 6))
plt.bar(grouped_likes['Platform'], grouped_likes['Daily_Usage_Time (minutes)'], color='lightgreen')

plt.title('Total Minutes Spend Per Platform')
plt.xlabel('PLatforms')
plt.ylabel('Minutes per day')

plt.figure(figsize=(10, 6))
ax = sns.countplot(data=df3, x=df3['Dominant_Emotion'], palette='pastel')
plt.title(f'Count Plot of Dominant Emotion')
plt.xlabel('Dominant_Emotion')
plt.ylabel('Count')
plt.grid(True)
for container in ax.containers:
    ax.bar_label(container, fmt = '%d')
plt.show()

import matplotlib.pyplot as plt
import seaborn as sns


numerical_df = df3.select_dtypes(include=['number'])


correlation_matrix = numerical_df.corr()


plt.figure(figsize=(10, 8))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm')
plt.title('Correlation Heatmap of the Data')
plt.show()

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import OneHotEncoder, StandardScaler
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.ensemble import RandomForestClassifier
from xgboost import XGBClassifier
from sklearn.metrics import classification_report

df3.isnull().sum()

df3.dropna(inplace=True)

df3.head()

X = df3.drop(columns=['Dominant_Emotion', 'User_ID']) # Features
y = df3['Dominant_Emotion'] # Target

# Split into training and test sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

numeric_features = ['Daily_Usage_Time (minutes)', 'Posts_Per_Day', 'Likes_Received_Per_Day', 'Comments_Received_Per_Day', 'Messages_Sent_Per_Day']
categorical_features = ['Age', 'Gender', 'Platform']

preprocessor = ColumnTransformer(
    transformers=[
        ('num', StandardScaler(), numeric_features),
        ('cat', OneHotEncoder(), categorical_features)])

rf_pipeline = Pipeline(steps=[('preprocessor', preprocessor),
                              ('classifier', RandomForestClassifier(random_state=42))])

rf_pipeline.fit(X_train, y_train)
y_pred_rf = rf_pipeline.predict(X_test)

print("Random Forest Classifier Report:")
print(classification_report(y_test, y_pred_rf))

from sklearn.preprocessing import LabelEncoder
# Encode target labels as integers
label_encoder = LabelEncoder()
y_encoded = label_encoder.fit_transform(y)

X_train, X_test, y_train, y_test = train_test_split(X, y_encoded, test_size=0.2, random_state=42)

# XGBoost Classifier
xgb_pipeline = Pipeline(steps=[('preprocessor', preprocessor),
                               ('classifier', XGBClassifier(random_state=42))])

xgb_pipeline.fit(X_train, y_train)
y_pred_xgb = xgb_pipeline.predict(X_test)

y_test_decoded = label_encoder.inverse_transform(y_test)
y_pred_xgb_decoded = label_encoder.inverse_transform(y_pred_xgb)

print("XGBoost Classifier Report:")
print(classification_report(y_test_decoded, y_pred_xgb_decoded))

from sklearn.tree import DecisionTreeClassifier

# Encode target labels as integers
label_encoder = LabelEncoder()
y_encoded = label_encoder.fit_transform(y)

# Split into training and test sets
X_train, X_test, y_train, y_test = train_test_split(X, y_encoded, test_size=0.2, random_state=42)

# Decision Tree Classifier
dt_pipeline = Pipeline(steps=[('preprocessor', preprocessor),
                              ('classifier', DecisionTreeClassifier(random_state=42))])

dt_pipeline.fit(X_train, y_train)
y_pred_dt = dt_pipeline.predict(X_test)

y_test_decoded = label_encoder.inverse_transform(y_test)
y_pred_dt_decoded = label_encoder.inverse_transform(y_pred_dt)

print("Decision Tree Classifier Report:")
print(classification_report(y_test_decoded, y_pred_dt_decoded))